<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<style type="text/css">
pre {margin-left:20pt; }
pre > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
pre > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }

p.example { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract { margin-left: 2em; background-color: #F5F6A2;
  border: 1px solid #E1E28E; }

p.function { }
.attribute { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;
  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5empadding-right: 0.5em; ; }

blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }

table.header { border: 0px; border-spacing: 0;
  margin-left: 0px; font-style: normal; }

table { border: 1px solid black; border-spacing: 0px;
  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none; 
  padding-right: 0.4em; border: none; }
td { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none;
  padding-right: 0.4em; border: none; }
</style>

<title>Change is_transparent to metafunction</title>
</head>

<body>

<table class="header"><tbody>
  <tr>
    <th>Document number:&nbsp;&nbsp;<th> <td></td>
  </tr>
  <tr>
    <th>Date:&nbsp;&nbsp;<th> <td></td>
  </tr>
  <tr>
    <th>Project:&nbsp;&nbsp;<th> <td>Programming Language C++, Library Evolution Working Group</td>
  </tr>
  <tr>
    <th>Reply-to:&nbsp;&nbsp;<th> <td><address>Tomasz Kamiński &lt;tomaszkam at gmail dot com&gt;</address></td>
  </tr>
</tbody></table>

<h1><a name="title">Change is_transparent to metafunction</a></h1>

<h2><a name="intro">Introduction</a></h2>

<p>This proposal discusses an alternative design for enabling a heterogeneous lookup function in the associative containers in the form of a metafunction.</p>

<p>This paper is result of the LWG recommendation provided in the resolution of the <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4383.html#2430">LWG issue #2430</a>.</p>

<!--h2><a name="toc">Table of contents</a></h2-->

<h2><a name="motivation">Motivation and Scope</a></h2>

<p>In the scope of this paper we propose a new metafunction <code>permits_heterogenous_lookup</code>.
This metafunction is designed to be used to enable the heterogeneous lookup in associative container, instead
of the current standard method relying on presence of <code>is_transparent</code> nested type in the comparator
type ($23.2.4 [associative.reqmts]).</p>

<h3><a name="motivation.backward-compatibility">Presreving backward compatibility</a></h3>

<p>The addition of the heterogeneous lookup to the container may silently change the behavior of the existing code,
and to avoid such situations it was designed as an opt-in feature. However, the mechanism created for the purpose
is not always working correctly - existing programs may define <code>is_transparent</code> nested type in their
comparator type, and as a consequence the meaning of such programs will be changed.</p>

<p>The introduction of the type trait allows the users to resolve the backward compatibility problem described above
via providing an explicit specialization of the trait that derives from the <code>std::false_type</code>. 
It is worth noting that this is only a viable resolution for the situation when the programmer does not have the
controll over the comparator's code.</p>

</p>Futhermore, it is possible to avoid false positives via providing the default definition
of <code>permits_heterogenous_lookup</code> that has BaseCharacteristic of <code>std::false_type</code>.
However, such design will no longer support user-defined comparators that intentionally enable new lookup function
by declaring nested type <code>is_transparent</code>.</p>

<p>The resolution of this problem is discussed in <a href="design.backward-compatibility">Backward compatibility</a>
subsection of the proposal.</p>

<h3><a name="motivation.third-party">Support for third party comparators</a></h3>

<p>In the current design enabling heterogeneous lookup requires a modification of the comparator class to 
declare a nested type. As a consequence of this intrusiveness, the users cannot enable this functionality
for the third-party comparison types that are outside of their control, even if they know that such operation
is supported.</p>

<p>In contrast, the use of a type trait allows the new lookup mechanism to be enabled in the program without any
modification to the third party libraries.</p>


<h3><a name="motivation.wrappers">Creating transparent call wrappers</a></h3>

<p>The introduction of the type trait would also simplify the definition of call wrapper types that would like 
to 'inherit' the heterogenous comparison trait from the wrapped callable.</p>

<p>Suppose we are creating <code>call_wrapper&lt;F&gt;</code>. In the case of the proposed <code>permits_heterogenous_lookup</code>
trait, the implementation is pretty straight-forward:</p>
<pre>namespace std
{
  template&lt;typename F&gt;
  struct permits_heterogenous_lookup&lt;call_wrapper&lt;F&gt;&gt; 
    : permits_heterogenous_lookup&lt;F&gt; {}; 
}</pre>

<p>But for current design it becomes more complicated. The user is required to declare <code>is_transparent</code> nested 
type in the definition of <code>call_wrapper&lt;F&gt;</code> if such type was defined in the <code>F</code> type.</p>
<pre>namespace detail 
{
  template&lt;typename F, typename IT = void&gt;
  struct is_transparent_base {};


  template&lt;typename F&gt;
  struct is_transparent_base&lt;F, void_t&lt;typename F::is_transparent&gt;&gt;
  {
    using is_transparent = typename F::is_transparent; 
  };
}

template&lt;typename F&gt;
struct call_wrapper : detail::is_transparent_base&lt;F&gt;
{ /*<i>...</i>*/ };</pre>

<p>In addition to being longer and intrusive, the nested type implementation requires of type <code>F</code> to 
be complete and becomes the point of instantiation of <code>call_wrapper&lt;F&gt;</code>.
As a consequence, it is impossible to create a reference wrapper class that would support both incomplete types and
heterogeneous container lookup.</p>

<h3><a name="motivation.consistency">Consistency with the Standard</a></h3>

<p>Proposed solution will make this functionality consistent with rest of the standard that relies on the usage
of the traits like: <code>is_placeholder</code> and <code>is_bind_expression</code> 


<h2><a name="design">Design Decisions</a></h2>

<p>Name,
Place in the standard,
Support for reference_wrapper and not_fn</p>


<h3><a name="design.backward-compatibility">Backward compatibility</a></h3>

<p>As the result of the introduction of <code>is_transparent</code> tag in the C++14 the design of <code>permits_heterogenous_lookup</code>
must carefully decide to choose one of the following:</p>   
  <ol>
    <li>Fix the pre-C++14 code compatibility problem that may be the result of silently enabling heterogeneous container lookup for
    existing comparators that have coincidentally provided the declaration of <code>is_transparent</code> nested type.
    To achieve that, the default implementation of the metafunction should return false.</li>
    <li>Preserve the support for post-C++14 user-defined comparator types that intentionally enable heterogenous
    container lookup via the declaration of <code>is_transparent</code> nested type. To achieve that, the default
    implementation of the metafunction should return true for the functors with this type present.</li>
  </ol>

<p>Considering the fact that we are addressing a rare problem, and the fact the harm was already done
(C++14 was shipped), the proposal decides to choose second option and provide the default implementation
that relies on presence of the nested type.</p>

<p>As a consequence of this decision, two ways of enabling hetergenous lookup are provided by the standard:
via the declaration of the nested type, and the explicit sepcialization of the trait. The author strongly believes
that the usage of the new mechanism should be encouraged.</p>

<h2><a name="standard">Impact On The Standard</a></h2>

<p>This proposal has no dependencies beyond a C++11 compiler and Standard Library implementation.</p>

<p>Nothing depends on this proposal.</p>


<h2><a name="feature-testing">Feature-testing recommendation</a></h2>

<p>For the purposes of SG10, we recommend the macro name <code>__cpp_lib_permits_heterogenous_lookup</code>.</p>

<h2><a name="wording">Proposed wording</a></h2>

<h2><a name="acknowledgements">Acknowledgements</a></h2>

<p>Jonathan Wakely provided a simplified wording for the LWG issue #2430, from which this paper originates.</p>
<p>Andrzej Krzemieński offered many useful suggestions and corrections to the proposal.</p>


<h2><a name="literature">References</a></h2>

<ol>
<li>Marshall Clow, "C++ Standard Library Active Issues List (Revision R92)" (N4383, <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4383.html">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4383.html</a>)</li>
</ol>

</body></html>
