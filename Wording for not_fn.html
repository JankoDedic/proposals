<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<style type="text/css">
pre {margin-left:20pt; }
pre > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
pre > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }

p.example { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract { margin-left: 2em; background-color: #F5F6A2;
  border: 1px solid #E1E28E; }

p.function { }
.attribute { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;
  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5empadding-right: 0.5em; ; }

blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }

p.comment {
  max-width: 80%;
  margin: 1ex;
  border: 1px dashed #888;
  padding: 1ex;
  background-color: #ffffe6;
}

table.header { border: 0px; border-spacing: 0;
  margin-left: 0px; font-style: normal; }

table { border: 1px solid black; border-spacing: 0px;
  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none; 
  padding-right: 0.4em; border: none; }
td { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none;
  padding-right: 0.4em; border: none; }
</style>

<title>Wording for 'not_fn'</title>
</head>

<body>

<table class="header"><tbody>
  <tr>
    <th>Document number:&nbsp;&nbsp;</th><th> </th><td></td>
  </tr>
  <tr>
    <th>Date:&nbsp;&nbsp;</th><th> </th><td></td>
  </tr>
  <tr>
    <th>Project:&nbsp;&nbsp;</th><th> </th><td>Programming Language C++, Library Working Group</td>
  </tr>
  <tr>
    <th>Reply-to:&nbsp;&nbsp;</th><th> </th><td><address>Tomasz Kamiński &lt;tomaszkam at gmail dot com&gt;</address></td>
  </tr>
</tbody></table>

<h1><a name="title">Wording for <code>not_fn</code></a></h1>

<h2><a name="intro">1. Introduction</a></h2>

<p>This paper proposes alternate wording for <code>std::not_fn</code>, that avoid defining behaviour
   in terms of implementation of exposition only class.</p>

<!--h2><a name="toc">Table of contents</a></h2-->


<h2><a name="motivation">2. Motivation and Scope</a></h2>

<p>Wording presented in this paper introduces <i>perfect forwarding call wrapper</i> concept, that
   groups a set of common requirements for call wrapper around stateful callable object(s) and
   collection bound arguments:</p>
<ol>
  <li>Value category and mutability of the wrapper is propagated for the call. This affect any member of the 
      call wrapper that is passed to underlining <code><em>INVOKE</em></code> expression, i.e. both
      callable and bound arguments.</li>
  <li>Call wrapper invocation is required to have same effects as the underlining <code><em>INVOKE</em></code>
      expression, including unevaluated context.</li> 
  <li>Copy and move construction on the call wrapper is required to have same semantics (including
      noexcept specification) as corresponding memberwise operation.</li>
</ol>
<p>To avoid potential confusion, existing <i>forwarding call wrapper</i> concept is renamed to <i>argument forwarding
   call wrapper</i>, to better reflect its functionality.</p>

<p>Proposed concept is later used in the specification of result of the existing <code>std::not_fn</code> function,
   but is also meant to cover common requirement for the upcoming <code>overload</code> and proposed <code>bind_front</code> 
   functions. In addition it can be used in <code>std::mem_fn</code> specification.</p>

TODO:
- why value category and costness propagation
- why noexcept for move construction (SOO in std::function)
- why SFINAE (concepts and std::function constructors)

<h2><a name="design">3. Design Decisions</a></h2>

TODO:
- do not require assignment (difference if reference_wrapper is unwrapped)
- do not require call to be conditionally constexpr (STL issue)
- do not require call to be conditionally noexcept (maybe? std::function)?

<h2><a name="wording.proposed">4. Proposed wording</a></h2>

<p>The proposed wording changes refer to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4582.pdf">N4582</a> (C++ Working Draft, 2016-03-19).</p>


<p>Apply following changes to paragraph 20.12.2 Requirements [func.require]:</p>
<blockquote class="std"> 
  <dl class="attribute">
    <dd>Every call wrapper (20.12.1) shall be <code>MoveConstructible</code>.

        A<ins>n</ins> <em><ins>argument</ins> forwarding call wrapper</em> is a call wrapper that
        can be called with an arbitrary argument list and delivers the arguments to the wrapped 
        callable object as references. This forwarding step shall ensure that rvalue arguments
        are delivered as rvalue references and lvalue arguments are delivered as lvalue references.

        A <em>simple call wrapper</em> is a<ins>n argument</ins> forwarding call wrapper that is <code>CopyConstructible</code>
        and <code>CopyAssignable</code> and whose copy constructor, move constructor, and assignment
        operator do not throw exceptions. 
       
        [ Note: In a typical implementation <ins>argument</ins> forwarding call wrappers
        have an overloaded function call operator of the form
<pre>template&lt;class... UnBoundArgs&gt;
R operator()(UnBoundArgs&amp;&amp;... unbound_args) cv-qual;</pre>
        — end note ].<p></p></dd>

     <dd><ins>A <em>perfect forwarding call wrapper</em> is an argument forwarding call wrapper
         that propagates its members to the underlining <code><em>INVOKE</em></code> expression
         on callable [ Note: This typically includes also wrapped callable - end note ]. This
         propagation step shall ensure that the member of type <code>T</code> is delivered
         as lvalue reference to <code>T <em>cv</em></code> when call is preformed on 
         lvalue of the wrapper type and rvalue reference to <code>T <em>cv</em></code>
         otherwise, where <code><em>cv</em></code> represents <em>cv</em>-qualifiers of wrapper.
         The <code><em>cv</em></code> shall be neither <code>volatile</code> nor <code>const volatile</code>.
         <ins><p></p></dd>

     <dd><ins>Whenever the specification requires that the call expression on the perfect forwarding
         call wrapper  is equivalent to some expression <code><em>e</em></code>, then it shall be interpreted 
         the same way as Equivalent to: <code>return <em>e</em></code> in an <em>Effects:</em> element of
         corresponding the call operator (17.5.1.4 [structure.specifications]).
         <ins><p></p></dd>

     <dd><ins>The copy and move constructors of the prefect forwarding call wrapper shall have the same semantics as
         if the corresponding operation would be explicitly defaulted oni the first declaration (8.4.2 [dcl.fct.def.default])
         [ Note: This means that prefect forwarding call wrapper type is CopyConstructible when type of its members
           satisfy requirements of CopyConstructible - end note. ].
        <ins><p></p></dd>    
  </dl>
</blockquote>

<p>Change the section 20.12.9 Function template <code>not_fn</code> [func.not_fn] to:</p>
<blockquote class="stdins"> 

<pre>  template &lt;class F&gt;
    <em>unspecified</em> not_fn(F&amp;&amp; f);
</pre>

  <dl class="attribute">

    <dd><p>In the text that follows:</p>
    <ul>
      <li><code>FD</code> is the type <code>decay_t&lt;F&gt;</code>,</li>
      <li><code>g</code> is a call wrapper created as a result of <code>not_fn(f)</code>,</li>
      <li><code>fd</code> is an exposition only member of <code>g</code> 
           of type <code>FD</code> constructed from <code>std::forward&lt;F&gt;(f)</code>,</li>
    </ul><p></p></dd>

    <dt>Requires:</dt> 
    <dd><code>FD</code> shall satisfy the requirements of <code>MoveConstructible</code>.
        <code>is_constructible_v&lt;FD, F&gt;</code> shall be true.
        <code>fd</code> shall be a callable object ([func.def] 20.12.1).
    <p></p></dd>

    <dt>Returns:</dt>
    <dd><p>A perfect forwarding call wrapper <code>g</code> such that the expression <code>g(a1, a2, ..., aN)</code> 
           is equivalent to <code>!<em>INVOKE</em>(fd, a1, a2, ..., aN)</code> ([func.require] 20.12.2).</p></dd>

    <dt>Throws:</dt>
    <dd><p>Any exception thrown by construction of <code>fd</code>.</p></dd>

  </dl>
</blockquote>

<p>Replace all references to forwarding call wrapper with argument forwarding call wrapper in following sections:<p>
<ul>
   <li>20.12.10.3 Function template <code>bind</code> [func.bind.bind]</li>
   <li> D.7.2 Typedefs to support function binders [depr.func.adaptor.typedefs].</li>
</ul>

<h2><a name="acknowledgements">6. Acknowledgements</a></h2>

<h2><a name="literature">7. References</a></h2>

<ol>
<li>Richard Smith, "Working Draft, Standard for Programming Language C++" (N4582, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf</a>)</li>
</ol>

</body></html>
